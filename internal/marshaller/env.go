package marshaller

import (
	"fmt"
	"sort"
	"strings"
)

// ENVMarshaller handles ENV format marshalling.
type ENVMarshaller struct{}

// Marshal marshals data to ENV format.
func (em *ENVMarshaller) Marshal(data map[string]interface{}) ([]byte, error) {
	var lines []string
	flattened := make(map[string]string)
	em.flattenMap("", data, flattened)

	// Sort keys for deterministic output
	keys := make([]string, 0, len(flattened))
	for k := range flattened {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Add header comment
	lines = append(lines, "# Environment variables generated by Konfigo")
	lines = append(lines, "")

	for _, k := range keys {
		lines = append(lines, fmt.Sprintf("%s=%s", k, flattened[k]))
	}

	return []byte(strings.Join(lines, "\n")), nil
}

// Format returns the format name.
func (em *ENVMarshaller) Format() string {
	return "env"
}

// flattenMap is a recursive helper to flatten the map for .env output.
func (em *ENVMarshaller) flattenMap(prefix string, data map[string]interface{}, flattened map[string]string) {
	for k, v := range data {
		var sb strings.Builder
		if prefix != "" {
			sb.WriteString(prefix)
			sb.WriteString("_")
		}
		sb.WriteString(k)
		newKey := strings.ToUpper(sb.String())

		switch val := v.(type) {
		case map[string]interface{}:
			// If it's a map, recurse
			em.flattenMap(newKey, val, flattened)
		case string:
			// Enhanced string handling with better quoting logic
			if em.needsQuoting(val) {
				flattened[newKey] = fmt.Sprintf("%q", val)
			} else {
				flattened[newKey] = val
			}
		case nil:
			// Handle nil values
			flattened[newKey] = ""
		default:
			// For other types (int, bool, etc.), convert to string
			flattened[newKey] = fmt.Sprintf("%v", v)
		}
	}
}

// needsQuoting determines if a string value needs to be quoted in ENV format.
func (em *ENVMarshaller) needsQuoting(s string) bool {
	if s == "" {
		return true
	}
	
	// Check for characters that require quoting
	requiresQuoting := []string{" ", "\t", "\n", "\r", "#", "\"", "'", "\\", "="}
	for _, char := range requiresQuoting {
		if strings.Contains(s, char) {
			return true
		}
	}
	
	return false
}
